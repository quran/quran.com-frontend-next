# Commit Changes

Analyze staged and unstaged changes, split them into logical commits with descriptive messages.

## Arguments

`$ARGUMENTS` can be:

- Empty: Analyze all changes and suggest commits
- `--all` or `-a`: Stage and commit all changes
- `--amend`: Amend the last commit (use with caution)

## Important Rules

### No AI Attribution

**NEVER mention "Claude", "Claude Code", "AI", or any AI assistant in commit messages.**

Bad examples:

- `fix: resolve bug (generated by Claude)`
- `feat: add feature - AI assisted`
- `refactor: cleanup code with Claude Code`

Good examples:

- `fix: resolve translation dropdown appearing on mode switch`
- `feat: add reading translation mode`
- `refactor: simplify audio player state management`

## Steps

### 1. Gather Information

Run these commands in parallel:

```bash
# Check current status
git status

# See staged changes
git diff --cached --stat

# See unstaged changes
git diff --stat

# See recent commits for message style reference
git log --oneline -10
```

### 2. Analyze Changes

Group changes by:

- **Feature/Component**: Changes to the same feature should be together
- **Type**: Separate fixes, features, refactors, and style changes
- **Independence**: Changes that can stand alone should be separate commits

### 3. Determine Commit Strategy

#### Single Commit

Use when:

- All changes are related to one feature/fix
- Changes are small (< 5 files, < 100 lines)
- Changes cannot logically be separated

#### Multiple Commits

Use when:

- Changes touch multiple unrelated features
- Mix of different change types (fix + feature + refactor)
- Changes can be logically separated and independently reverted
- Large changes that benefit from granular history

### 4. Generate Commit Plan

For each proposed commit, provide:

```markdown
### Commit 1: [type]: [short description]

**Files:**

- path/to/file1.tsx
- path/to/file2.scss

**Message:**
```

[type]: [concise description]

[Optional body explaining why, not what]

```

**Reasoning:** Why these files are grouped together
```

### 5. Execute Commits

After user approval, for each commit:

```bash
# Stage specific files
git add <file1> <file2> ...

# Create commit with message
git commit -m "[message]"
```

## Commit Message Format

### Structure

```
<type>(<optional scope>): <description>

[optional body]

[optional footer]
```

### Types

| Type       | Description                                             |
| ---------- | ------------------------------------------------------- |
| `feat`     | New feature                                             |
| `fix`      | Bug fix                                                 |
| `refactor` | Code change that neither fixes a bug nor adds a feature |
| `style`    | Formatting, missing semicolons, etc.                    |
| `docs`     | Documentation only                                      |
| `test`     | Adding or updating tests                                |
| `chore`    | Maintenance tasks, dependencies                         |
| `perf`     | Performance improvement                                 |

### Description Guidelines

- Use imperative mood: "add" not "added" or "adds"
- Don't capitalize first letter
- No period at the end
- Keep under 50 characters
- Be specific: "fix dropdown z-index in header" not "fix bug"

### Body Guidelines (Optional)

- Wrap at 72 characters
- Explain "why" not "what" (the diff shows what)
- Include context that isn't obvious from the code

### Examples

**Simple fix:**

```
fix: resolve translation dropdown appearing on mode switch
```

**Feature with scope:**

```
feat(reader): add reading translation mode
```

**With body:**

```
fix: prevent duplicate API calls on page navigation

The useEffect was missing a dependency check, causing
the fetch to trigger on every render instead of only
when the page parameter changed.
```

**With ticket reference:**

```
fix(QF-4006): resolve context menu centering issue
```

## Splitting Strategy

### By Component/Feature

```
# Instead of one big commit:
"update reader and settings"

# Split into:
1. "feat(reader): add translation page component"
2. "feat(settings): add reading translation preference"
3. "style(reader): update translation page styles"
```

### By Change Type

```
# Instead of:
"fix bugs and add features"

# Split into:
1. "fix: resolve dropdown z-index issue"
2. "feat: add translation mode toggle"
3. "refactor: extract shared styles to constants"
```

### By Independence

Ask: "Could this change be reverted independently?"

If yes → separate commit If no → same commit

## Output

1. Display the commit plan with all proposed commits
2. Ask user to:
   - Approve the plan
   - Modify groupings
   - Edit messages
3. After approval, execute commits in order
4. Show final `git log --oneline -n [number of commits]` to confirm

## Edge Cases

### Partially Staged Files

If a file has both staged and unstaged changes:

- Ask user if they want to commit only staged changes
- Or stage all changes for that file

### Untracked Files

- List untracked files separately
- Ask which should be included
- Warn about potentially sensitive files (.env, credentials, etc.)

### Empty Commit

If no changes to commit:

- Inform user there are no changes
- Show current git status
